谈到算法，最常见的就是几种排序及查找算法。找工作大多数人会找出来复习一遍，抽空亲手写了一遍，也顺便做个总结。对于排序及查找算法我们不仅应该关注其代码实现，还应该关注它的时间复杂度、空间复杂度及稳定性。深入理解它在什么情况下时间复杂度最好、什么情况下时间复杂度较高, 并懂得将其思想灵活应用其他情况中。

### 排序空间、时间复杂度总结
排序时间复杂度 ![排序算法复杂度对比](https://raw.githubusercontent.com/gokerwin/blog_meta/master/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.jpg)
### 几种常见数据结构操作性能
常见数据结构操作性能 ![数据结构性能对比](https://raw.githubusercontent.com/gokerwin/blog_meta/master/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.jpg)

### 快速排序
```
function quick_sort($begin, $end, &$data)
{
	$loc = 0;
	if($begin < $end){
		$loc = partition($data, $begin, $end);
		quick_sort($begin, $loc-1, $data);
		quick_sort($loc+1, $end, $data);
	}
}
function partition(&$data, $begin, $end)
{
	$pro = $data[$begin];
	$p1 = $begin;
	$p2 = $end;
	while($p1 < $p2){
		while($data[$p2] > $pro && $p1 < $p2){
			$p2--;
		}
		$data[$p1] = $data[$p2];
		while($data[$p1] <= $pro && $p1 < $p2){
			$p1++;
		}
		$data[$p2] = $data[$p1];
		
	}
	
	$data[$p1] = $pro;
	return $p1;
}
```

### 堆排序
```
function heap_sort(&$data)
{
	$len = count($data);
	//大堆
	build_heap($data, $len);
	while($len > 1){
		$tmp = $data[$len - 1];
		$data[$len - 1] = $data[0];
		$data[0] = $tmp;
		$len--;
		adjust_heap($data, $len, 0);
	}
}
function build_heap(&$data, $len)
{
	$begin = $len / 2 - 1;
	for($i = $begin; $i >= 0; $i--){
		adjust_heap($data, $len, $i);
	}
}
function adjust_heap(&$data, $len, $i)
{
	$index = $i;
	$left = 2 * $i + 1;
        $right = 2 * ($i + 1);
  	if ($left < $len && $data[$i] < $data[$left]) {
        	$index = $left;
 	 }
	
	if ($right < $len && $data[$index] < $data[$right]) {
        	$index = $right;
  	}
 	
	if ($index != $i) {
		$tmp = $data[$index];
		$data[$index] = $data[$i];
		$data[$i] = $tmp;
    		adjust_heap($data, $len, $index); // 递归调整
  	}      
}
```

### 归并排序
```
void merge_sort_union(int begin, int middle, int end, int data[], int array_length)
{
	int result[array_length];
	int ptr1 = begin; 
	int ptr2 = middle;
	for(int i = 0; i < array_length; ){
		if(ptr1 == middle){
			result[i++] = data[ptr2++];
			continue;
		}
		if(ptr2 == end+1){
			result[i++] = data[ptr1++];
			continue;
		}
		if(data[ptr1] <= data[ptr2])
			result[i++] = data[ptr1++];
		if(data[ptr2] < data[ptr1])
			result[i++] = data[ptr2++];
	}
	for(int i = begin, j = 0; i <= end; )
		data[i++] = result[j++];
}
void merge_sort(int begin, int end, int data[], int array_length)
{
	if(end - begin <= 1){
		if(data[begin] > data[end]){
	    	int tmp = data[begin];
	    	data[begin] = data[end];
	    	data[end] = tmp;
		}
		return;
	}
	int middle = begin + (end - begin) / 2;
	merge_sort(begin, middle, data, middle-begin+1);
    merge_sort(middle+1 ,end, data, end-middle);
    merge_sort_union(begin, middle+1, end, data, array_length);
}
```

### 冒泡排序
```
void pre_bubble_sort(int *data, int len)
{
	while(len >= 1){
		int flag = 0;
		for(int i = 0; i <= len-2; i++){
			if(data[i] > data[i+1]){
				int tmp = data[i+1];
				data[i+1] = data[i];
				data[i] = tmp;
				flag = 1;
			}
		}
		if(flag == 0)
			break;
		len--;
	}
}
```

### 插入排序
```
void insert_sort(int *data, int len)
{
	for(int i = 1; i <= len-1; i++){
		int val = data[i];
		int index = 0;
		for(int j = i-1; j >= 0; j--){
			if(val > data[j]){
				index = j+1;
				break;   //！！！跳出循环！！！
			}
		}
		for(int q = i; q > index; q--)
			data[q] = data[q-1];
		
		data[index] = val;
		printf("排序后: ");
		for(int i=0; i<len; i++){
			printf("%d ", data[i]);
		}
		printf("\n");
	}
}
```

### 选择排序
```
void select_sort(int *data, int len)
{
	int index = 0;
	while(index <= len-1){
		int min = data[index];
		int mindex = index;
		for(int i = index+1; i <= len-1; i++){
			if(data[i] < min){
				min = data[i];
				mindex = i;
			}
		}
		if(mindex != index){
			int tmp = data[index];
			data[index] = data[mindex];
			data[mindex] = tmp;
		} else {
			index++;
		}
	}
}
```

