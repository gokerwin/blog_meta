一般来说，较好技术型公司对团队成员的技术素质都较高，都要求人员有较好的算法基础。当然，就我个人的经验而言，面试难度越高，人员素质卡的越严格，这样的公司越值得加入。面试过程中，算法属于必考题型，数组、字符串相关的算法也最容易考察。说到算法，大多数人脑中浮现的第一想法就是二分查找、快速排序、堆排序之类的。但是，这一类型的算法思路基本被考烂了，大多数公司不再选择这些作为考点，反而更多考察数组、字符串相关的算法题。

### 数组求和
> 给定一个含有n个元素的整型数组a，求a中所有元素的和。要求用递归实现，且只用一行代码。

- 分析:
  - 如果数组元素个数为0，那么和为0。
  - 如果数组元素个数为n，那么先求出前n-1个元素之和，再加上a[n-1]即可。

- 代码：
```
function sum(array $arr, $len)
{
	return ($len == 0) ? 0 : (sum($arr, $len-1) + $arr[$len-1]);
}
```

### 求数组的最大值和最小值
> 给定一个含有n个元素的整型数组a，找出其中的最大值和最小值

- 分析
  - 常规的做法是遍历一次，分别求出最大值和最小值。
  - 优化方案：分治法，将数组分成左右两部分，先求出左边的最大值和最小值，再求出右边的最大值和最小值，然后综合起来求总体的最大值及最小值。用递归实现。
  - 扩展：求数组的最大值和次大值。 思想类似，同样可用分治法。但是要注意需要处理最大元素有多个的情况，比如 [3, 5, 7, 7] 可能返回 (7, 7) , 而不是 (7, 5) 。

- 代码
```
funciton findMaxAndMin(array $arr, $low, $high, &$max, $$min)
{
    if($high - $low == 0) {    //只有一个元素
        $max = $arr[$low];
        $min = $arr[$low];
        return;
    }
    if($high - $low == 1) {     //只有两个元素
        if($arr[$high] >= $arr[$low]) {
            $max = $arr[$high];
        	$min = $arr[$low];
        } else {
            $max = $arr[$low];
        	$min = $arr[$high];
        }
        return ;
    }
    $mid = intval(($low + $high) / 2);  //取整
    findMaxAndMin($arr, $low, $mid, $lmax, $lmin) ; // 递归计算左半部份
    findMaxAndMin($arr, $mid+1, $high, $rmax, $rmin) ; // 递归计算右半部份
    $max = max($lmax, $rmax) ; // 总的最大值
    $min = min($lmin, $rmin) ; // 总的最小值
}
```

### 求数组中出现次数超过一半的元素
> 给定一个含n个整型元素的数组a，其中有一个元素出现次数超过 n / 2 ，求这个元素。

- 分析
  - 参考编程之美，寻找发帖水帖王。
  - 设置一个当前值curVal和当前值的计数器count，遍历整个数组，对于每个被遍历到的值a[i],若与当前值相同则计数器加1，不同则计算器减1，计数器为0，给当前值赋新值。
  - 另一种方法：先对数组排序，然后取中间元素即可，因为超过一半，该元素必定占据数组中间位置。
  - 扩展：求3个元素均超过 1 / 4 。

- 代码
```
function findMajor(array $arr, $len)
{
	$count = 0;
    for ($i = 1; $i < $len; $i++) {
    	if($count == 0){
    		$curVal = $arr[$i];
    		$count++;
    		continue;
    	}
    	
    	if($arr[$i] == $curVal)
    		$count++;
    	else if($arr[$i] != $curVal)
    		$count--;
    }
    return $curVal;
}
```

### 求数组中元素的最短距离
> 给定一个含有n个元素的整型数组，找出数组中的两个元素 x 和 y 使得 abs(x-y) 值最小。

- 分析
    - 先对数组排序，然后遍历一次即可。

- 代码
```
function minDistance(array $arr, $len)
{
	sort($arr);
	$low = $arr[0];
	$high = $arr[1];
	$distance = $arr[1] - $arr[0];
	for($i = 1; $i < $len-1; $i++){
		if($arr[$i+1] - $arr[$i] < $distance){
			$distance = $arr[$i+1] - $arr[$i];
			$low = $arr[$i];
			$high = $arr[$i+1];
		}
	}
	echo $distance . " - " . $low . " - " . $high . "\n"; 
}
```

### 求两个有序数组的共同元素
> 给定两个含有n个元素的有序（非降序）整型数组a和b，求出其共同元素。
比如：
a = 0, 1, 2, 3, 4
b = 1, 3, 5, 7, 9 
输出 1, 3

- 分析
	- 充分利用数组**有序**的性质，用两个指针i和j分别指向a和b，比较a[i]和b[j]，根据比较结果移动指针，则有如下三种情况:
		1. ```a[i] < b[j]```，则 i 增加1，继续比较
		2. ```a[i] == b[j]```，则 i 和 j 皆加1，继续比较
		3. ```a[i] < b[j]```，则 j 加1，继续比较
	- 扩展: a、b为有序数组，求b是否是a的子串。

- 代码
```
function findMix(array $arr_a, array $arr_b, $len)
{
	$ptr_a = 0;
	$ptr_b = 0;
	$mix = [];
	while($ptr_a < $len && $ptr_b < $len){
		if($arr_a[$ptr_a] == $arr_b[$ptr_b]){
			$mix[] = $arr_a[$ptr_a];
			$ptr_a++;
			$ptr_b++;
		}
		else if($arr_a[$ptr_a] > $arr_b[$ptr_b]){
			$ptr_b++;
		}
		else {
			$ptr_a++;
		}
	}
	return $mix;
}
```

### 求三个数组的共同元素
> 给定三个含有n个元素的整型数组a, b 和 c，求他们最小的共同元素。

- 分析
  - 如果三个数组都有序，那么可以设置三个指针指向三个数组的头部，然后根据这三个指针所指的值进行比较来移动指针，直到找到共同元素。
  - 如果三个数组都无序，可以先对a, b进行排序（基数排序时间复杂度为O(n)、快速排序\堆排序 时间复杂度为O(nlogn) ），然后对c中任意一个元素都在 b 和 c 中做二分查找。
  - 扩展：求m个含有n个元素的整型数组的交集。
  - 总结：对于数组交集、并集、合并问题，一般可分如下两种情况来处理: i. 如果给定的数组有序，那么可以考虑多指针移动对比和二分查找。 ii. 如果给定的数组无序，那么应想到对数组进行排序。
  
### 找出数组中唯一的重复元素
> 给定含有1001个元素的数组，其中存放了1-1000之内的整数，只有一个整数是重复的，请找出这个数。

- 分析
  - 先遍历数组求出整个数组的和，再利用公式求出1-1000的和，相减。
  
### 找出数组中出现为奇数次的元素
> 给定一个含有n个元素的整型数组a，其中只有一个元素出现奇数次，其他均出现偶数次，找出这个元素。

- 分析
    - 对于任意一个数k，有k ^ k = 0，k ^ 0 = k，所以将a中所有元素进行异或，那么个数为偶数的元素异或后都变成了0，只留下了个数为奇数的那个元素。
    - 扩展：找出数组中唯一一个出现一次的元素，其他均出现两次。

- 代码
```
function findOddCount(array $arr, $len)
{
	$ret = $arr[0];
    for($i = 0; $i < $len; $i++) {
        $ret ^= $arr[$i] ;
    }
    return $ret;
}
```

### 求有序数组中满足给定和的数对
> 给定两个有序整型数组a和b，各有n个元素，求两个数组中满足给定和x的数对，即存在a中元素a[i]和b中元素b[j]，满足a[i] + b[j] = x(x已知)，求i，j。

- 分析
    - 利用有序性，两个指针i， j， i指向a的首部，j指向b的首尾，遍历。
	- 扩展：给定一个有序数组a，查找a中是否存在两个数之和等于x。

- 代码
```
function fixedSum(array $arr_a, array $arr_b, $len, $sum)
{
	$ptr_a = 0;
	$ptr_b = $len-1;
	while($ptr_a < $len && $ptr_b >= 0){
		if($arr_a[$ptr_a] + $arr_b[$ptr_b] == $sum){
			echo $arr_a[$ptr_a] . " + " . $arr_b[$ptr_b] . "\n";
			$ptr_a++;
			$ptr_b--;
		} else if($arr_a[$ptr_a] + $arr_b[$ptr_b] < $sum){
			$ptr_a++;
		} else if($arr_a[$ptr_a] + $arr_b[$ptr_b] > $sum){
			$ptr_b--;
		}
	}	
}
```

### 求最大子段和
> 输入一个整形数组，包含正数和负数。数组中连续的一个或多个整数组成一个子数组。 求所有子数组的和的最大值，要求时间复杂度为O(n)。
示例：
输入的数组为
[3, 10, -4, 7, -1, 5],
和最大的子数组为[3, 10, -4, 7], 因此输出为20

- 分析
	- 扩展：求最大子段积。注意处理负数的情况。
	
- 代码
```
//begin和end分别表示最大子段和的开始和结束位置的下标，下标从0开始。  
int maxSum(int a[],int n,int &begin,int &end){  
    int sum=0;//sum保存的是当前连续几个数的和的最大值，只是记录目前算得得最大值。  
    int tem=0;//tem表示决策第i个数时所保存的第i-1个数决策状态。  
    for(int i=0;i<n;i++){  
        if(tem>0)  
            tem+=a[i];//如果tem>0，说明tem可  
        else{  
            tem=a[i];  
            begin=i;//如果tem小于等于零，说明重新计算最大字段和，记下开始位置  
        }  
        if(tem>sum){  
            sum=tem;  
            end=i;//如果tem>sum，说明刷新了最大子段和的值，记下结束位置  
        }  
    }  
    return sum;  
}
```

### 数组循环移位
> 将一个含有n个元素的数组向右循环移动k位，要求时间复杂度是O(n)，且只能使用两个额外的变量。这是编程之美上的一道题

- 分析
    - 比如数组 1 2 3 4 循环右移1位 将变成 4 1 2 3， 观察可知1 2 3 的顺序在移位前后没有改变，只是和4的位置交换了一下，所以等同于1 2 3 4 先划分为两部分 1 2 3 | 4，然后将1 2 3逆序，再将4 逆序 得到 3 2 1 4，最后整体逆序 得到 4 1 2 3
    - 稍微扩展一下,如果允许分配额外的数组,那么定义一个新的数组,然后将移位后的元素直接存入即可,也可以使用队列,将移动后得元素出对,再插入队尾即可。

- 代码
```
// 将buffer中start和end之间的元素逆序
void Reverse( int buffer[], int start, int end )
{
    while ( start < end ) {
        int temp = buffer[ start ] ;
        buffer[ start++ ] = buffer[ end ] ;
        buffer[ end-- ] = temp ;
    }
}
// 将含有n个元素的数组buffer右移k位
void Shift( int buffer[], int n, int k )
{
    k %= n ;
    Reverse( buffer, 0, n - k - 1) ;
    Reverse( buffer, n - k, n - 1 ) ;
    Reverse( buffer, 0, n - 1 ) ;
}
```

### 字符串逆序
> 给定一个含有n个元素的字符数组a，将其原地逆序。

- 分析
    - 题目要求是原地逆序，也就是不允许额外分配空间。用两个指针分别指向字符数组的首位，交换其对应的字符，然后两个指针分别向数组中央移动，直到交叉。

- 代码
```
// 字符串逆序
void Reverse(char *a, int n)
{
     int left = 0; 
     int right = n - 1;
     while (left < right) {
         char temp = a[left] ;
         a[left++] = a[right] ;
         a[right--] = temp ;
     }
}
```

### 字符串排列问题
> 给定一个字符串，字符串中字母不重复，求该该字符串中字母的所有排列。
比如:
字符串 abc的所有排列为：
abc、bac、cba、acb、bca、cab

- 分析
    - 典型的排列组合问题。思路 用第一个字母分别与后面字母交换位置构成新的

- 代码
```
// n选m的所有组合
int buffer[100] ;
void PrintArray(int *a, int n)
{
    for (int i = 0; i < n; ++i)
        cout << a[i] << "";
    cout << endl ;
}
bool IsValid(int lastIndex, int value)
{
    for (int i = 0; i < lastIndex; i++)
    {
        if (buffer[i] >= value)
            return false;
    }
    return true;
}
void Select(int t, int n, int m)
{
    if (t == m)
        PrintArray(buffer, m);
    else
    {
        for (int i = 1; i <= n; i++) {
            buffer[t] = i;
            if (IsValid(t, i))
                Select(t + 1, n, m);
        }
    }
}
```

### 字符串组合问题
> 给定一个含有n个元素的整型数组a，从中任取m个元素，求所有组合。比如
a = 1, 2, 3, 4, 5
m = 3
输出
[{1 2 3}, {1 2 4}, {1 2 5}, {1 3 4}, {1 3 5}, {1 4 5},
{2 3 4}, {2 3 5}, {2 4 5}, {3 4 5}]

- 分析
    - 典型的排列组合问题，首选回溯法，为了简化问题，我们将a中n个元素值分别设置为1-n

 - 代码
```
// n选m的所有组合
int buffer[100] ;
void PrintArray(int *a, int n)
{
    for (int i = 0; i < n; ++i)
        cout << a[i] << "";
    cout << endl ;
}
bool IsValid(int lastIndex, int value)
{
    for (int i = 0; i < lastIndex; i++)
    {
        if (buffer[i] >= value)
            return false;
    }
    return true;
}
void Select(int t, int n, int m)
{
    if (t == m)
        PrintArray(buffer, m);
    else
    {
        for (int i = 1; i <= n; i++) {
            buffer[t] = i;
            if (IsValid(t, i))
                Select(t + 1, n, m);
        }
    }
}
```

### 字符串求回文串
> 合并两个数组
给定含有n个元素的两个有序（非降序）整型数组a和b。合并两个数组中的元素到整型数组c，要求去除重复元素并保持c有序（非降序）。例子如下
a = 1, 2, 4, 8
b = 1, 3, 5, 8
c = 1, 2, 3, 4, 5, 8

- 分析
    - 利用合并排序的思想，两个指针i,j和k分别指向数组a和b，然后比较两个指针对应元素的大小。

- 代码
```
// 合并两个有序数组
void Merge(int *a, int *b, int *c, int n)
{
    int i = 0 ;
    int j = 0 ;
    int k = 0 ;
    while (i < n && j < n) {
        if (a[i] < b[j])// 如果a的元素小，则插入a中元素到c
        {
            c[k++] = a[i] ;
            ++i ;
        }
        else if (a[i] == b[j])// 如果a和b元素相等，则插入二者皆可，这里插入a
        {
            c[k++] = a[i] ;
            ++i ;
            ++j ;
        }
        else // a[i] > b[j] // 如果b中元素小，则插入b中元素到c
        {
            c[k++] = b[j] ;
            ++j ;
        }
    }
    if (i == n)   // 若a遍历完毕，处理b中剩下的元素
    {
        for (int m = j; m < n; ++m)
            c[k++] = b[m] ;
    }
    else      //j == n, 若b遍历完毕，处理a中剩下的元素
    {
        for (int m = i; m < n; ++m)
            c[k++] = a[m] ;
    }
}
```

### 数组重排问题
> 给定含有n个元素的整型数组a，其中包括0元素和非0元素，对数组进行排序，要求：
排序后所有0元素在前，所有非零元素在后，且非零元素排序前后相对位置不变
不能使用额外存储空间
例子如下
输入 0, 3, 0, 2, 1, 0, 0
输出 0, 0, 0, 0, 3, 2, 1

- 分析
    - 它要求排序前后非0元素的相对位置不变。可以从后向前遍历整个数组，遇到某个位置i上的元素是非0元素时，如果a[k]为0，则将a[i]赋值给a[k]，a[k]赋值为0。实际上i是非0元素的下标，而k是0元素的下标。

- 代码
```
void Arrange(int* a, int n)
{
    int k = n -1 ;
    for (int i = n -1; i >=0; --i) {
        if (a[i] !=0) {
            if (a[k] ==0) {
                a[k] = a[i] ;
                a[i] =0 ;
            }
            --k ;
        }
    }
}
```

### 找出绝对值最小的元素
> 给定一个有序整数序列（非递减序），可能包含负数，找出其中绝对值最小的元素，比如给定序列 -5, -3, -1, 2, 8 则返回1。

- 分析
    - 由于给定序列是有序的，而这又是搜索问题，所以首先想到二分搜索法，只不过这个二分法比普通的二分法稍微麻烦点，可以分为下面几种情况
    - 如果给定的序列都是正数，那么第一个元素即是结果。
    - 如果给定的序列都是负数，那么最后一个元素即是结果。
    - 如果给定的序列中既有正数又有负数，那么绝对值得最小值一定出现在正数和负数的连接处。

- 代码
```
bool SameSign(int a, int b)
{
    if (a * b > 0)
        return true;
    else
        return false;
}
// 找出一个非递减序整数序列中绝对值最小的数
int MinimumAbsoluteValue(int* a, int n)
{
    // Only one number in array
    if (n ==1) {
        return a[0] ;
    }
    // All numbers in array have the same sign
    if (SameSign(a[0], a[n -1])) {
        return a[0] >=0? a[0] : a[n -1] ;
    }
    // Binary search
    int l =0 ;
    int r = n -1 ;
    while(l < r) {
        if (l + 1 == r) {
            return abs(a[l]) < abs(a[r]) ? a[l] : a[r] ;
        }
        int m = (l + r) /2 ;
        if (SameSign(a[m], a[r])) {
            r = m;
            continue;
        }
        else {
            l = m ;
            continue;
        }
    }
}
```

### 数组原地去重
> 给定一个有重复数字的数组，要求原地去重，空间复杂度为O(1)

### 数组找左边比它小右边比它大的元素
> 给定一个数组，寻找左边都比它小，右边都比它大的元素。要求时间复杂度和空间复杂度均为O(N)。eg: 21 11 30 35 9 68 78 86 70 100 120 111

- 分析
    - 从左往右遍历遍，把所有子串的最大值存在数组arr1。从右往左遍历一遍，把所有子串的最小值存在数组arr2。
    - 最后遍历一遍数组，比较每个元素与它左右子串的最大、最小值。
    - 注意：比较要注意细节，头尾元素特殊处理，比较左右子串，不包含元素本身。

- 代码
```
function findMid(array $arr, $len)
{
	$minArg = [];
	$maxArg = [];
	$max = -PHP_INT_MAX;
	$min = PHP_INT_MAX;
	for($i = 0; $i < $len; $i++){
		if($arr[$i] > $max){
			$maxArg[$i] = $arr[$i];
			$max = $arr[$i];
		} else {
			$maxArg[$i] = $max;
		}
	}
	for($i = $len-1; $i >= 0; $i--){
		if($arr[$i] < $min){
			$minArg[$i] = $arr[$i];
			$min = $arr[$i];
		} else {
			$minArg[$i] = $min;
		}
	}
	$ret = [];
	if($len <= 1)
		return $arr;
	if($arr[0] < $minArg[1])
		$ret[] = $arr[0];
	if($arr[$len-1] > $maxArg[$len-2])
		$ret[] = $arr[$len-1];
	for($i = 1; $i < $len-1; $i++){
		if($arr[$i] > $maxArg[$i-1] && $arr[$i] < $minArg[$i+1])
			$ret[] = $arr[$i];
	}
	return $ret;
}
```

### 统计数字在排序数组中出现的次数

todo

